using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web.Services.Protocols;
using WSSAT.DataTypes;

namespace WSSAT.BusinessLayer
{
    public class DynamicVulnerabilityScanner
    {
        private MainForm mainForm;

        public DynamicVulnerabilityScanner(MainForm mainForm)
        {
            this.mainForm = mainForm;
        }

        public void ScanVulnerabilities(WebServiceToInvoke wsInvoker, WSOperation operation, VulnerabilitiesVulnerability vuln,
            string targetNameSpace, WSDescriber wsDesc, WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject,
            bool isDebug, ref List<Param> respHeader, string customSoapHeaderTags, string customSoapBodyTags, string customRequestHeader)
        {
            if (vuln.id == 1) // check authentication
            {
                CheckUnAuthenticatedMethod(wsInvoker, operation, vuln, targetNameSpace, WSItemVulnerabilities, reportObject, isDebug, ref respHeader, customSoapHeaderTags, customSoapBodyTags, customRequestHeader);
            }
            else
            {
                CheckVulnsExceptAuth(wsInvoker, operation, vuln, targetNameSpace, wsDesc, WSItemVulnerabilities, reportObject, isDebug, ref respHeader, customSoapHeaderTags, customSoapBodyTags, customRequestHeader);
            }
        }

        private void CheckVulnsExceptAuth(WebServiceToInvoke wsInvoker, WSOperation operation, VulnerabilitiesVulnerability vuln,
           string targetNameSpace, WSDescriber wsDesc, WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject,
            bool isDebug, ref List<Param> respHeader, string customSoapHeaderTags, string customSoapBodyTags, string customRequestHeader)
        {
            int paramIndexToTest = 0;

            for (int i = 0; i < operation.Parameters.Count; i++)
            {
                if (i == paramIndexToTest)
                {
                    foreach (string payload in vuln.request)
                    {
                        bool vulnFoundForParam = false;

                        wsInvoker.AddParameter(operation.Parameters[i].Name, payload.Trim());
                        for (int j = 0; j < operation.Parameters.Count; j++)
                        {
                            if (j != paramIndexToTest)
                            {
                                SetParameterDefaultValue(wsInvoker, operation.Parameters[j], isDebug);
                            }
                        }

                        try
                        {
                            try
                            {
                                reportObject.TotalRequestCount++;
                                wsInvoker.InvokeMethod(operation.MethodName, targetNameSpace, wsDesc, ref respHeader, customSoapHeaderTags, customSoapBodyTags, customRequestHeader);
                            }
                            catch (SoapException soapEx)
                            {
                                SetSoapFaultException(operation, soapEx, WSItemVulnerabilities, isDebug);
                            }
                            catch (Exception ex)
                            {
                                throw ex;
                            }
                        }
                        finally { wsInvoker.PosInvoke(); }

                        mainForm.Log("   StatusCode: " + wsInvoker.StatusCode, FontStyle.Regular, isDebug, false);
                        mainForm.Log("   Result: " + wsInvoker.ResultString, FontStyle.Regular, isDebug, false);

                        if (!string.IsNullOrEmpty(vuln.statusCode))
                        {
                            if (vuln.statusCode.Equals(wsInvoker.StatusCode.ToString()))
                            {
                                if (vuln.response == null || vuln.response.Count() == 0)
                                {
                                    SetVuln(wsInvoker, WSItemVulnerabilities, vuln, operation, payload, operation.Parameters[i].Name, "   " + vuln.title + " Vulnerability Found: " + wsInvoker.ResultString + " - Status Code: " + vuln.statusCode);
                                    vulnFoundForParam = true;
                                }
                                else
                                {
                                    foreach (string text in vuln.response)
                                    {
                                        if (wsInvoker.ResultString.Trim().Contains(text.Trim()))
                                        {
                                            SetVuln(wsInvoker, WSItemVulnerabilities, vuln, operation, payload, operation.Parameters[i].Name, "   " + vuln.title + " Vulnerability Found: " + wsInvoker.ResultString + " - Response Text Contains: " + text + " - Status Code: " + vuln.statusCode);
                                            vulnFoundForParam = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            foreach (string text in vuln.response)
                            {
                                //if (System.Text.RegularExpressions.Regex.IsMatch(wsInvoker.ResultString.Trim(), text.Trim(), System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                                if (wsInvoker.ResultString.Trim().Contains(text.Trim()))
                                {
                                    // Vulnerability Found
                                    SetVuln(wsInvoker, WSItemVulnerabilities, vuln, operation, payload, operation.Parameters[i].Name, "   " + vuln.title + " Vulnerability Found: " + wsInvoker.ResultString + " - Response Text Contains: " + text);
                                    vulnFoundForParam = true;
                                    break;
                                }
                            }
                        }
                        if (vulnFoundForParam)
                        {
                            break;
                        }
                    }
                }
                paramIndexToTest++;
            }
        }

        private void SetVuln(WebServiceToInvoke wsInvoker, WSDescriberForReport WSItemVulnerabilities,
            VulnerabilitiesVulnerability vuln, WSOperation operation, string payload, string paramName, string logStr)
        {
            mainForm.Log(logStr, FontStyle.Bold, true, false);
            VulnerabilityForReport vulnRep = new VulnerabilityForReport();
            vulnRep.Vuln = vuln;
            vulnRep.VulnerableMethodName = operation.MethodName;
            vulnRep.VulnerableParamName = paramName;
            vulnRep.Payload = payload;
            vulnRep.Response = wsInvoker.ResultString;
            vulnRep.StatusCode = wsInvoker.StatusCode.ToString();

            WSItemVulnerabilities.Vulns.Add(vulnRep);
        }

        private void CheckUnAuthenticatedMethod(WebServiceToInvoke wsInvoker, WSOperation operation, VulnerabilitiesVulnerability vuln,
            string targetNameSpace, WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject,
            bool isDebug, ref List<Param> respHeader, string customSoapHeaderTags, string customSoapBodyTags, string customRequestHeader)
        {
            for (int j = 0; j < operation.Parameters.Count; j++)
            {
                SetParameterDefaultValue(wsInvoker, operation.Parameters[j], isDebug);
            }

            try
            {
                try
                {
                    reportObject.TotalRequestCount++;
                    wsInvoker.InvokeMethod(operation.MethodName, targetNameSpace, null, ref respHeader, customSoapHeaderTags, customSoapBodyTags, customRequestHeader);
                }
                catch (SoapException soapEx)
                {
                    //throw ex;
                    SetSoapFaultException(operation, soapEx, WSItemVulnerabilities, isDebug);
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            finally { wsInvoker.PosInvoke(); }

            if (!vuln.statusCode.Equals(wsInvoker.StatusCode.ToString())) // status code != 401, no redirection
            {
                VulnerabilityForReport authVuln = new VulnerabilityForReport();
                authVuln.Vuln = MainForm.vulnerabilities.Vulnerability.Where(v => v.id == 1).FirstOrDefault();
                authVuln.VulnerableMethodName = operation.MethodName;
                authVuln.VulnerableParamName = "";
                authVuln.Payload = "";
                authVuln.Response = wsInvoker.ResultString;
                authVuln.StatusCode = wsInvoker.StatusCode.ToString();

                WSItemVulnerabilities.Vulns.Add(authVuln);

                mainForm.Log("   Auth Vulnerability Found: " + wsInvoker.ResultString + " - status code is : " + wsInvoker.StatusCode.ToString(), FontStyle.Bold, true, false);
            }
        }

        public void CheckHTTPOptionsVulns(WSDescriber wsDesc, VulnerabilitiesVulnerability vuln, 
            WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject, bool isDebug, 
            ref List<Param> respHeader, string customRequestHeader)
        {
            CheckWebServerVulns(wsDesc, vuln, WSItemVulnerabilities, reportObject, isDebug,
                ref respHeader, customRequestHeader, "HTTP OPTIONS", "OPTIONS");
        }

        public void CheckXSTVulns(WSDescriber wsDesc, VulnerabilitiesVulnerability vuln,
           WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject, bool isDebug,
           ref List<Param> respHeader, string customRequestHeader)
        {
            CheckWebServerVulns(wsDesc, vuln, WSItemVulnerabilities, reportObject, isDebug,
                ref respHeader, customRequestHeader, "Cross Site Tracing", "TRACE");
        }

        private void CheckWebServerVulns(WSDescriber wsDesc, VulnerabilitiesVulnerability vuln,
            WSDescriberForReport WSItemVulnerabilities, ReportObject reportObject, bool isDebug,
            ref List<Param> respHeader, string customRequestHeader, string methodName, string httpMethodName)
        {
            HttpWebResponseWrapper response = null;
            try
            {
                RestHTTPHelper HttpHelper = new RestHTTPHelper();
                reportObject.TotalRequestCount++;

                response = HttpHelper.GetHttpWebResponseForWebServerVuln(wsDesc.WSUri.Scheme + "://" + wsDesc.WSUri.Host + ":" + wsDesc.WSUri.Port,
                    wsDesc.BasicAuthentication, ref respHeader, customRequestHeader, httpMethodName);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            if (response != null && response.WebResponse != null)
            {
                if (vuln.statusCode.Equals(((int)response.WebResponse.StatusCode).ToString())) // status code == 200
                {
                    VulnerabilityForReport optionsVuln = new VulnerabilityForReport();
                    optionsVuln.Vuln = vuln;
                    optionsVuln.VulnerableMethodName = wsDesc.WSUri.Host + ":" + wsDesc.WSUri.Port;
                    optionsVuln.VulnerableParamName = "";
                    optionsVuln.Payload = "";
                    optionsVuln.Response = response.ResponseBody;
                    optionsVuln.StatusCode = response.WebResponse.StatusCode.ToString();

                    WSItemVulnerabilities.Vulns.Add(optionsVuln);

                    mainForm.Log("   " + methodName + " is enabled: " + response.ResponseBody + " - status code is : " + response.WebResponse.StatusCode.ToString(), FontStyle.Bold, true, false);
                }
            }
        }

        private void SetParameterDefaultValue(WebServiceToInvoke wsInvoker, WSParameter wSParameter, bool isDebug)
        {
            switch (wSParameter.TypeName)
            {
                case "int":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.IntDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.IntDefaultVal);
                    break;
                case "string":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.StringDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.StringDefaultVal);
                    break;
                case "double":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.DoubleDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.DoubleDefaultVal);
                    break;
                case "decimal":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.DecimalDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.DecimalDefaultVal);
                    break;
                case "boolean":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.BooleanDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.BooleanDefaultVal);
                    break;
                case "bool":
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.BooleanDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.BooleanDefaultVal);
                    break;
                default:
                    mainForm.Log("   " + wSParameter.Name + " - " + wSParameter.TypeName + ":" + DefaultValues.StringDefaultVal, FontStyle.Regular, isDebug, false);
                    wsInvoker.AddParameter(wSParameter.Name, DefaultValues.StringDefaultVal);
                    break;
            }
        }

        public void SetSoapFaultException(WSOperation operation, SoapException soapEx, WSDescriberForReport WSItemVulnerabilities, bool isDebug)
        {
            if (WSItemVulnerabilities.Vulns.Where(v => v.VulnerableMethodName.Equals(operation.MethodName) && v.Vuln.id == 7).Count() <= 0) // aynı method için sadece 1 tane soap fault zafiyeti yaz
            {
                mainForm.Log("   Soap Exception: " + soapEx.ToString(), FontStyle.Regular, isDebug, false);

                VulnerabilityForReport soapFaultVuln = new VulnerabilityForReport();
                soapFaultVuln.Vuln = MainForm.vulnerabilities.Vulnerability.Where(v => v.id == 7).FirstOrDefault();
                soapFaultVuln.VulnerableMethodName = operation.MethodName;
                soapFaultVuln.VulnerableParamName = "";
                soapFaultVuln.Payload = "";
                soapFaultVuln.Response = soapEx.Message;
                soapFaultVuln.StatusCode = "";

                WSItemVulnerabilities.Vulns.Add(soapFaultVuln);
            }
        }

    }
}
